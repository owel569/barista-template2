[
  {
    "type": "add_line_analysis",
    "content": "The following code corrects TypeScript typings for inventory and marketing analysis, and anomalies, ensuring better type safety and predictability within the AI Automation Service."
  },
  {
    "type": "replace_code",
    "content": "import { z } from 'zod';\n\n// === TYPES ET INTERFACES ===\ninterface StaffingRecommendation {\n  optimal: number;\n  minimum: number;\n  peakHourBoost: number;\n  recommendations: string[];\n}\n\ninterface MarketingOpportunity {\n  type: string;\n  suggestion: string;\n  expectedImpact: string;\n  confidence: number;\n}\n\ninterface CustomerFlowPrediction {\n  peakPeriods: Array<{ \n    time: string;\n    expectedCustomers: number;\n    confidence: number;\n  }>;\n  quietPeriods: Array<{ \n    time: string;\n    expectedCustomers: number;\n    confidence: number;\n  }>;\n}\n\n// Sch√©mas de validation pour les services internes\nconst ChatContextSchema = z.object({\n  message: z.string().min(1),\n  userId: z.string().optional(),\n  sessionId: z.string().optional(),\n  context: z.record(z.unknown()).optional()\n});\n\nconst VoiceAnalysisSchema = z.object({\n  audioData: z.string(),\n  language: z.string().default('fr-FR'),\n  userId: z.string().optional()\n});\n\nconst PredictionContextSchema = z.object({\n  timeframe: z.enum(['daily', 'weekly', 'monthly']).default('daily'),\n  metrics: z.array(z.string()).optional()\n});\n\n// Base de connaissances enrichie pour le caf√©\nconst CAFE_KNOWLEDGE_BASE = {\n  menu: {\n    'cappuccino': { price: 4.50, description: 'Caf√© espresso avec mousse de lait onctueuse', category: 'boissons-chaudes' },\n    'latte': { price: 5.00, description: 'Caf√© au lait avec art latte', category: 'boissons-chaudes' },\n    'americano': { price: 3.50, description: 'Espresso allong√© √† l\'eau chaude', category: 'boissons-chaudes' },\n    'croissant': { price: 2.50, description: 'Viennoiserie fran√ßaise traditionnelle', category: 'patisseries' },\n    'muffin': { price: 3.00, description: 'Muffin aux myrtilles fait maison', category: 'patisseries' },\n    'sandwich-jambon': { price: 6.50, description: 'Sandwich jambon beurre sur pain frais', category: 'plats' }\n  },\n  horaires: {\n    'lundi': '7h00 - 19h00', 'mardi': '7h00 - 19h00', 'mercredi': '7h00 - 19h00',\n    'jeudi': '7h00 - 19h00', 'vendredi': '7h00 - 20h00', 'samedi': '8h00 - 20h00', 'dimanche': '8h00 - 18h00'\n  },\n  services: {\n    'wifi': 'WiFi gratuit disponible - mot de passe: CafeBarista2024',\n    'parking': 'Parking gratuit disponible derri√®re le caf√©',\n    'groupes': 'Nous acceptons les groupes jusqu\'√† 15 personnes avec r√©servation',\n    'livraison': 'Livraison disponible dans un rayon de 5km',\n    'fid√©lit√©': 'Programme de fid√©lit√© : 10√®me caf√© offert'\n  },\n  promotions: {\n    'happy-hour': 'Happy Hour 15h-17h : -20% sur les boissons',\n    'menu-dejeuner': 'Menu d√©jeuner 12h-14h : plat + boisson = 9‚Ç¨',\n    'weekend': 'Weekend : brunch sp√©cial 9h-12h'\n  }\n};\n\nimport { getDb } from '../db';\nimport { customers, orders, menuItems, reservations, menuCategories } from '../../shared/schema';\nimport { eq, sql, desc, and, gte, lte } from 'drizzle-orm';\nimport { createLogger } from '../middleware/logging';\n\nconst logger = createLogger('AI_AUTOMATION_SERVICE');\n\ninterface ChatMessage {\n  message: string;\n  userId?: number;\n}\n\ninterface PredictionRequest {\n  type: 'sales' | 'traffic' | 'inventory';\n  period: string;\n}\n\ninterface VoiceRequest {\n  audioData: string;\n  userId?: number;\n}\n\ninterface AnomalyRequest {\n  metric: string;\n  period: string;\n}\n\n// Placeholder types for clarity, replace with actual types if available\n// Removed duplicate interface definitions\n// type StaffingRecommendation = any;\n// type MarketingOpportunity = any;\n\n/**\n * Service central d\'Intelligence Artificielle pour Barista Caf√©\n * G√®re toute la logique m√©tier IA : chat, pr√©dictions, analyse comportementale\n */\nexport class AIAutomationService {\n  private static instance: AIAutomationService;\n  private chatSessions: Map<string, Array<Record<string, unknown>>> = new Map();\n  private userPreferences: Map<string, Record<string, unknown>> = new Map();\n\n  static getInstance(): AIAutomationService {\n    if (!AIAutomationService.instance) {\n      AIAutomationService.instance = new AIAutomationService();\n    }\n    return AIAutomationService.instance;\n  }\n\n  // === CHAT & CONVERSATION ===\n\n  async processChatMessage(data: z.infer<typeof ChatContextSchema>) {\n    const { message, userId, sessionId, context } = ChatContextSchema.parse(data);\n\n    try {\n      // R√©cup√©ration du contexte de session\n      const session = this.getOrCreateSession(sessionId || userId || 'anonymous');\n\n      // Analyse d\'intention avec IA\n      const intent = await this.detectIntent(message, context);\n\n      // G√©n√©ration de r√©ponse contextuelle\n      const response = await this.generateContextualResponse(message, intent, session, userId);\n\n      // Sauvegarde dans l\'historique\n      this.updateSession(sessionId || userId || 'anonymous', { message, response, intent });\n\n      return {\n        response: response.text,\n        actions: response.actions,\n        intent: intent.category,\n        confidence: intent.confidence,\n        suggestions: response.suggestions,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      logger.error('Erreur traitement chat:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      return {\n        response: \"D√©sol√©, je rencontre une difficult√© technique. Puis-je vous aider autrement ?\",\n        actions: [],\n        intent: 'error',\n        confidence: 0,\n        suggestions: ['R√©essayer', 'Parler √† un employ√©'],\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  private async detectIntent(message: string, context?: Record<string, unknown>) {\n    const lowerMessage = message.toLowerCase();\n    const words = lowerMessage.split(' ');\n\n    // Scores d\'intention\n    const intentScores = {\n      menu: this.calculateScore(words, ['menu', 'carte', 'plat', 'boisson', 'manger', 'boire', 'prix', 'co√ªt']),\n      reservation: this.calculateScore(words, ['r√©server', 'table', 'places', 'r√©servation', 'libre', 'disponible']),\n      commande: this.calculateScore(words, ['commander', 'prendre', 'voudrais', 'acheter', 'cappuccino', 'caf√©']),\n      horaires: this.calculateScore(words, ['horaires', 'ouvert', 'ferm√©', 'heure', 'quand']),\n      services: this.calculateScore(words, ['wifi', 'parking', 'livraison', 'groupe', 'fid√©lit√©']),\n      promotions: this.calculateScore(words, ['promotion', 'offre', 'r√©duction', 'prix', 'happy', 'menu']),\n      aide: this.calculateScore(words, ['aide', 'aider', 'probl√®me', 'question', 'comment'])\n    };\n\n    // D√©termination de l\'intention principale\n    const maxIntent = Object.keys(intentScores).reduce((a, b) => \n      intentScores[a as keyof typeof intentScores] > intentScores[b as keyof typeof intentScores] ? a : b\n    );\n\n    return {\n      category: maxIntent,\n      confidence: intentScores[maxIntent as keyof typeof intentScores],\n      subCategories: Object.keys(intentScores).filter(key => \n        key !== maxIntent && intentScores[key as keyof typeof intentScores] > 0.3\n      )\n    };\n  }\n\n  private calculateScore(words: string[], keywords: string[]): number {\n    const matches = words.filter(word => \n      keywords.some(keyword => word.includes(keyword) || keyword.includes(word))\n    );\n    return Math.min(matches.length / keywords.length + (matches.length * 0.2), 1);\n  }\n\n  private async generateContextualResponse(message: string, intent: { category: string; confidence: number }, session: unknown[], userId?: string) {\n    const { category, confidence } = intent;\n\n    switch (category) {\n      case 'menu':\n        return this.generateMenuResponse(message, session);\n\n      case 'reservation':\n        return this.generateReservationResponse(message, session, userId);\n\n      case 'commande':\n        return this.generateOrderResponse(message, session, userId);\n\n      case 'horaires':\n        return this.generateHoursResponse();\n\n      case 'services':\n        return this.generateServicesResponse(message);\n\n      case 'promotions':\n        return this.generatePromotionsResponse();\n\n      default:\n        return this.generateGeneralResponse(session);\n    }\n  }\n\n  private generateMenuResponse(message: string, session: unknown[]) {\n    const menuItems = Object.entries(CAFE_KNOWLEDGE_BASE.menu);\n    const menuText = menuItems.map(([name, info]) => \n      `‚Ä¢ ${name.charAt(0).toUpperCase() + name.slice(1)}: ${info.description} - ${info.price}‚Ç¨`\n    ).join('\\n');\n\n    return {\n      text: `üçΩÔ∏è **Notre Menu du Caf√© Barista**\\n\\n${menuText}\\n\\n‚ú® Que vous tente-t-il aujourd'hui ?`,\n      actions: [\n        { type: 'show_menu', data: CAFE_KNOWLEDGE_BASE.menu },\n        { type: 'show_categories', data: ['boissons-chaudes', 'patisseries', 'plats'] }\n      ],\n      suggestions: ['Commander un cappuccino', 'Voir les p√¢tisseries', 'R√©server une table']\n    };\n  }\n\n  private generateReservationResponse(message: string, session: unknown[], userId?: string) {\n    // Extraction des informations de r√©servation du message\n    const guestMatch = message.match(/(\\d+)\\s*(personne|gens|places)/i);\n    const guests = guestMatch && guestMatch[1] ? parseInt(guestMatch[1], 10) : null;\n\n    return {\n      text: `üè™ **R√©servation au Caf√© Barista**\\n\\n` +\n            `Je peux vous aider √† r√©server une table${guests ? ` pour ${guests} personnes` : ''}.\\n\\n` +\n            `Pour finaliser votre r√©servation, j'ai besoin de :\\n` +\n            `‚Ä¢ Date souhait√©e\\n‚Ä¢ Heure pr√©f√©r√©e\\n‚Ä¢ Nombre de personnes\\n‚Ä¢ Demandes sp√©ciales (optionnel)`,\n      actions: [\n        { type: 'open_reservation_form', data: { guests } },\n        { type: 'check_availability', data: { date: new Date().toISOString().split('T')[0] } }\n      ],\n      suggestions: ['R√©server pour ce soir', 'Voir les cr√©neaux libres', 'R√©server pour 4 personnes']\n    };\n  }\n\n  private generateOrderResponse(message: string, session: unknown[], userId?: string) {\n    // D√©tection des items mentionn√©s\n    const mentionedItems = Object.keys(CAFE_KNOWLEDGE_BASE.menu).filter(item =>\n      message.toLowerCase().includes(item.toLowerCase())\n    );\n\n    if (mentionedItems.length > 0) {\n      const item = mentionedItems[0];\n      const itemInfo = CAFE_KNOWLEDGE_BASE.menu[item as keyof typeof CAFE_KNOWLEDGE_BASE.menu];\n\n      return {\n        text: `‚òï **Excellent choix !**\\n\\n` +\n              `${item ? item.charAt(0).toUpperCase() + item.slice(1) : 'Article'} - ${itemInfo?.price || 0}‚Ç¨\\n` +\n              `${itemInfo?.description || ''}\\n\\n` +\n              `Voulez-vous l'ajouter √† votre commande ?`,\n        actions: [\n          { type: 'add_to_cart', data: { item, price: itemInfo?.price || 0, quantity: 1 } },\n          { type: 'show_similar_items', data: { category: itemInfo?.category || 'general' } }\n        ],\n        suggestions: ['Ajouter au panier', 'Voir d\'autres boissons', 'Finaliser la commande']\n      };\n    }\n\n    return {\n      text: `üõí **Passer une commande**\\n\\n` +\n            `Je peux vous aider √† commander ! Que souhaitez-vous?\\n\\n` +\n            `Nos sp√©cialit√©s :\\n‚Ä¢ Cappuccino artisanal\\n‚Ä¢ Croissants frais\\n‚Ä¢ Sandwichs maison`,\n      actions: [\n        { type: 'show_menu', data: CAFE_KNOWLEDGE_BASE.menu },\n        { type: 'show_popular_items' }\n      ],\n      suggestions: ['Voir le menu complet', 'Nos sp√©cialit√©s', 'Boissons chaudes']\n    };\n  }\n\n  private generateHoursResponse() {\n    const hours = Object.entries(CAFE_KNOWLEDGE_BASE.horaires)\n      .map(([day, hours]) => `‚Ä¢ ${day.charAt(0).toUpperCase() + day.slice(1)}: ${hours}`)\n      .join('\\n');\n\n    return {\n      text: `üïê **Horaires d'ouverture du Caf√© Barista**\\n\\n${hours}\\n\\nüìç Nous vous attendons !`,\n      actions: [{ type: 'show_location' }],\n      suggestions: ['Voir l\'adresse', 'R√©server maintenant', 'Nous contacter']\n    };\n  }\n\n  private generateServicesResponse(message: string) {\n    const lowerMessage = message.toLowerCase();\n    let specificService = null;\n\n    if (lowerMessage.includes('wifi')) specificService = 'wifi';\n    else if (lowerMessage.includes('parking')) specificService = 'parking';\n    else if (lowerMessage.includes('groupe')) specificService = 'groupes';\n    else if (lowerMessage.includes('livraison')) specificService = 'livraison';\n    else if (lowerMessage.includes('fid√©lit√©')) specificService = 'fid√©lit√©';\n\n    if (specificService) {\n      return {\n        text: `‚ÑπÔ∏è **${specificService.charAt(0).toUpperCase() + specificService.slice(1)}**\\n\\n${(CAFE_KNOWLEDGE_BASE.services as any)[specificService] || 'Information non disponible'}`, \n        actions: [{ type: 'show_all_services' }],\n        suggestions: ['Voir tous nos services', 'R√©server une table', 'Notre menu']\n      };\n    }\n\n    const servicesList = Object.entries(CAFE_KNOWLEDGE_BASE.services)\n      .map(([key, value]) => `‚Ä¢ **${key.charAt(0).toUpperCase() + key.slice(1)}**: ${value}`)\n      .join('\\n');\n\n    return {\n      text: `üõéÔ∏è **Nos Services**\\n\\n${servicesList}`,\n      actions: [{ type: 'contact_staff' }],\n      suggestions: ['R√©server une table', 'Commander en ligne', 'Nous contacter']\n    };\n  }\n\n  private generatePromotionsResponse() {\n    const promosList = Object.entries(CAFE_KNOWLEDGE_BASE.promotions)\n      .map(([key, value]) => `üéâ **${key.replace('-', ' ').toUpperCase()}**: ${value}`)\n      .join('\\n\\n');\n\n    return {\n      text: `üí∞ **Nos Promotions Actuelles**\\n\\n${promosList}\\n\\nüéÅ Profitez-en vite !`,\n      actions: [\n        { type: 'subscribe_promotions' },\n        { type: 'show_loyalty_program' }\n      ],\n      suggestions: ['S\'abonner aux offres', 'Programme fid√©lit√©', 'R√©server maintenant']\n    };\n  }\n\n  private generateGeneralResponse(session: unknown[]) {\n    return {\n      text: `üëã **Bienvenue au Caf√© Barista !**\\n\\n` +\n            `Je suis votre assistant virtuel. Je peux vous aider avec :\\n\\n` +\n            `‚òï Notre menu et nos sp√©cialit√©s\\n` +\n            `üè™ Les r√©servations de table\\n` +\n            `üõí Passer une commande\\n` +\n            `üïê Nos horaires et services\\n` +\n            `üéâ Nos promotions actuelles\\n\\n` +\n            `Comment puis-je vous aider aujourd'hui ?`,\n      actions: [\n        { type: 'quick_menu' },\n        { type: 'quick_reservation' },\n        { type: 'show_promotions' }\n      ],\n      suggestions: ['Voir le menu', 'R√©server une table', 'Nos promotions', 'Horaires d\'ouverture']\n    };\n  }\n\n  // === PR√âDICTIONS & ANALYTICS ===\n\n  async generatePredictiveAnalytics(context: z.infer<typeof PredictionContextSchema>) {\n    const { timeframe, metrics } = PredictionContextSchema.parse(context);\n\n    try {\n      const predictions = await this.calculatePredictions(timeframe);\n      const customerFlow = await this.predictCustomerFlow(timeframe);\n      const inventoryAlerts = await this.generateInventoryAlerts();\n      const revenueForecast = await this.forecastRevenue(timeframe);\n\n      return {\n        timeframe,\n        generatedAt: new Date().toISOString(),\n        predictions: {\n          revenue: revenueForecast,\n          customerFlow,\n          inventoryAlerts,\n          staffingRecommendations: await this.generateStaffingRecommendations(customerFlow),\n          marketingOpportunities: await this.identifyMarketingOpportunities()\n        },\n        confidence: {\n          overall: 0.87,\n          revenue: 0.92,\n          customerFlow: 0.85,\n          inventory: 0.94\n        }\n      };\n    } catch (error) {\n      logger.error('Erreur pr√©dictions IA:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      throw new Error('Impossible de g√©n√©rer les pr√©dictions');\n    }\n  }\n\n  private async calculatePredictions(timeframe: string) {\n    // Algorithme pr√©dictif bas√© sur les donn√©es historiques\n    const baseMetrics = {\n      dailyCustomers: 120,\n      averageOrderValue: 12.50,\n      peakHours: ['08:00-10:00', '12:00-14:00', '17:00-19:00']\n    };\n\n    const seasonalFactors = this.getSeasonalFactors();\n    const weekdayFactors = this.getWeekdayFactors();\n\n    return {\n      expectedCustomers: Math.round(baseMetrics.dailyCustomers * seasonalFactors.customer * weekdayFactors.customer),\n      expectedRevenue: Math.round(baseMetrics.dailyCustomers * baseMetrics.averageOrderValue * seasonalFactors.revenue * 100) / 100,\n      peakHours: baseMetrics.peakHours,\n      growthTrend: seasonalFactors.trend\n    };\n  }\n\n  private getSeasonalFactors() {\n    const month = new Date().getMonth();\n    const seasons = {\n      winter: { customer: 0.85, revenue: 0.90, trend: 'stable' },\n      spring: { customer: 1.10, revenue: 1.15, trend: 'growing' },\n      summer: { customer: 1.25, revenue: 1.30, trend: 'growing' },\n      autumn: { customer: 1.05, revenue: 1.10, trend: 'stable' }\n    };\n\n    if (month >= 11 || month <= 1) return seasons.winter;\n    if (month >= 2 && month <= 4) return seasons.spring;\n    if (month >= 5 && month <= 7) return seasons.summer;\n    return seasons.autumn;\n  }\n\n  private getWeekdayFactors() {\n    const day = new Date().getDay();\n    const factors = {\n      0: { customer: 1.15, revenue: 1.20 }, // Dimanche\n      1: { customer: 0.80, revenue: 0.85 }, // Lundi\n      2: { customer: 0.90, revenue: 0.95 }, // Mardi\n      3: { customer: 1.00, revenue: 1.00 }, // Mercredi\n      4: { customer: 1.10, revenue: 1.05 }, // Jeudi\n      5: { customer: 1.30, revenue: 1.25 }, // Vendredi\n      6: { customer: 1.40, revenue: 1.35 }  // Samedi\n    };\n    return factors[day as keyof typeof factors] || factors[0];\n  }\n\n  // === GESTION DE SESSION ===\n\n  private getOrCreateSession(sessionId: string): unknown[] {\n    if (!this.chatSessions.has(sessionId)) {\n      this.chatSessions.set(sessionId, []);\n    }\n    return this.chatSessions.get(sessionId)!;\n  }\n\n  private updateSession(sessionId: string, interaction: unknown) {\n    const session = this.getOrCreateSession(sessionId);\n    session.push({\n      ...(interaction || {}),\n      timestamp: new Date().toISOString()\n    });\n\n    // Limiter l\'historique √† 50 interactions\n    if (session.length > 50) {\n      session.splice(0, session.length - 50);\n    }\n  }\n\n  // === M√âTHODES UTILITAIRES ===\n\n  private async predictCustomerFlow(timeframe: string): Promise<CustomerFlowPrediction> {\n    try {\n      const db = getDb();\n\n      // Analyse des donn√©es historiques pour pr√©dire le flux\n      const historicalData = await db.select({\n        hour: sql`EXTRACT(HOUR FROM created_at)`,\n        avgCustomers: sql`COUNT(*)`, \n        dayOfWeek: sql`EXTRACT(DOW FROM created_at)`\n      }).from(orders)\n        .groupBy(sql`EXTRACT(HOUR FROM created_at)`, sql`EXTRACT(DOW FROM created_at)`)\n        .where(gte(orders.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)));\n\n      return {\n        peakPeriods: [\n          { time: '08:00-10:00', expectedCustomers: 45, confidence: 0.92 },\n          { time: '12:00-14:00', expectedCustomers: 65, confidence: 0.88 },\n          { time: '17:00-19:00', expectedCustomers: 40, confidence: 0.85 }\n        ],\n        quietPeriods: [\n          { time: '14:00-17:00', expectedCustomers: 15, confidence: 0.90 },\n          { time: '20:00-22:00', expectedCustomers: 20, confidence: 0.87 }\n        ]\n      };\n    } catch (error) {\n      logger.error('Erreur pr√©diction flux clients:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      return {\n        peakPeriods: [\n          { time: '08:00-10:00', expectedCustomers: 45, confidence: 0.92 },\n          { time: '12:00-14:00', expectedCustomers: 65, confidence: 0.88 },\n          { time: '17:00-19:00', expectedCustomers: 40, confidence: 0.85 }\n        ],\n        quietPeriods: [\n          { time: '14:00-17:00', expectedCustomers: 15, confidence: 0.90 },\n          { time: '20:00-22:00', expectedCustomers: 20, confidence: 0.87 }\n        ]\n      };\n    }\n  }\n\n  private async generateInventoryAlerts() {\n    try {\n      const db = getDb();\n\n      // Analyse des niveaux de stock et des tendances de vente\n      const inventoryAnalysis = await db.select({\n        itemName: menuItems.name,\n        currentStock: menuItems.stock || 0,\n        dailySales: sql`COALESCE(AVG(orders.quantity), 0)`,\n        daysRemaining: sql`CASE WHEN AVG(orders.quantity) > 0 THEN ${menuItems.stock || 0} / AVG(orders.quantity) ELSE 999 END`\n      }).from(menuItems)\n        .leftJoin(orders, eq(orders.id, menuItems.id))\n        .groupBy(menuItems.id, menuItems.name, menuItems.stock)\n        .where(gte(orders.createdAt, new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)));\n\n      return inventoryAnalysis.map((item: any) => ({\n        id: item.id,\n        name: item.itemName,\n        currentStock: item.currentStock,\n        optimalStock: item.optimalStock,\n        efficiency: item.efficiency,\n        recommendation: item.recommendation\n      }));\n    } catch (error) {\n      logger.error('Erreur analyse inventaire:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      return [\n        { item: 'Lait entier', level: 'low', currentStock: '5L', recommendedOrder: '20L', urgency: 'high' },\n        { item: 'Grains caf√© Arabica', level: 'medium', currentStock: '2kg', recommendedOrder: '10kg', urgency: 'medium' },\n        { item: 'Croissants', level: 'optimal', currentStock: '25 unit√©s', recommendedOrder: 'none', urgency: 'none' }\n      ];\n    }\n  }\n\n  private async forecastRevenue(timeframe: string) {\n    const base = 1250;\n    const variation = Math.random() * 200 - 100;\n    return {\n      predicted: Math.round(base + variation),\n      confidence: 0.89,\n      factors: ['M√©t√©o favorable', 'Promotion en cours', '√âv√©nement local']\n    };\n  }\n\n  private async generateStaffingRecommendations(customerFlow: CustomerFlowPrediction): Promise<StaffingRecommendation> {\n    const totalPeakCustomers = customerFlow.peakPeriods.reduce((sum, period) => sum + period.expectedCustomers, 0);\n    const totalQuietCustomers = customerFlow.quietPeriods.reduce((sum, period) => sum + period.expectedCustomers, 0);\n\n    // Calcul bas√© sur le ratio clients/employ√©s optimis√© pour un caf√©\n    const optimalPeakStaff = Math.ceil(totalPeakCustomers / 15);\n    const optimalQuietStaff = Math.ceil(totalQuietCustomers / 25);\n\n    return {\n      optimal: optimalPeakStaff,\n      minimum: optimalQuietStaff,\n      peakHourBoost: optimalPeakStaff - optimalQuietStaff,\n      recommendations: [\n        `Ajouter ${optimalPeakStaff - optimalQuietStaff} employ√©s pendant les heures de pointe`,\n        'Formation crois√©e du personnel pour plus de flexibilit√©',\n        'Optimiser les pauses pendant les heures creuses',\n        'Pr√©voir un serveur suppl√©mentaire le weekend'\n      ]\n    };\n  }\n\n  private async identifyMarketingOpportunities(): Promise<MarketingOpportunity[]> {\n    try {\n      const db = getDb();\n\n      // Analyse des tendances des ventes par cat√©gorie\n      const salesTrends = await db.select({\n        categoryId: menuItems.categoryId,\n        categoryName: menuCategories.name,\n        totalSales: sql`COALESCE(SUM(${orders.totalAmount}), 0)`,\n        growth: sql`\n          CASE \n            WHEN SUM(CASE WHEN orders.created_at >= NOW() - INTERVAL '14 days' AND orders.created_at < NOW() - INTERVAL '7 days' THEN orders.total_amount ELSE 0 END) > 0 \n            THEN (SUM(CASE WHEN orders.created_at >= NOW() - INTERVAL '7 days' THEN orders.total_amount ELSE 0 END) - \n                  SUM(CASE WHEN orders.created_at >= NOW() - INTERVAL '14 days' AND orders.created_at < NOW() - INTERVAL '7 days' THEN orders.total_amount ELSE 0 END)) / \n                 SUM(CASE WHEN orders.created_at >= NOW() - INTERVAL '14 days' AND orders.created_at < NOW() - INTERVAL '7 days' THEN orders.total_amount ELSE 0 END)\n            ELSE 0 \n          END`\n      }).from(orders)\n        .innerJoin(menuItems, eq(orders.itemId, menuItems.id))\n        .innerJoin(menuCategories, eq(menuItems.categoryId, menuCategories.id))\n        .groupBy(menuItems.categoryId, menuCategories.name)\n        .where(gte(orders.createdAt, new Date(Date.now() - 14 * 24 * 60 * 60 * 1000)));\n\n      const opportunities: MarketingOpportunity[] = salesTrends.map((trend: any) => ({\n        type: 'product_promotion',\n        title: `Promotion ${trend.productName}`,\n        description: `Augmentation de ${trend.growth}% des ventes`,\n        priority: trend.growth > 20 ? 'high' : 'medium',\n        estimatedImpact: trend.revenue,\n        recommendedActions: [`Mettre en avant ${trend.productName}`]\n      }));\n\n      // Ajouter des opportunit√©s g√©n√©riques bas√©es sur les donn√©es\n      opportunities.push(\n        {\n          type: 'happy_hour',\n          suggestion: 'Happy Hour 15h-17h avec -20% sur les boissons',\n          expectedImpact: '+25% de fr√©quentation',\n          confidence: 0.82\n        },\n        {\n          type: 'loyalty',\n          suggestion: 'Programme fid√©lit√© : 10√®me caf√© offert',\n          expectedImpact: '+15% de clients r√©guliers',\n          confidence: 0.78\n        }\n      );\n\n      return opportunities;\n    } catch (error) {\n      logger.error('Erreur opportunit√©s marketing:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      return [\n        {\n          type: 'promotion',\n          suggestion: 'Happy Hour 15h-17h avec -20% sur les boissons',\n          expectedImpact: '+25% de fr√©quentation',\n          confidence: 0.82\n        },\n        {\n          type: 'loyalty',\n          suggestion: 'Programme fid√©lit√© : 10√®me caf√© offert',\n          expectedImpact: '+15% de clients r√©guliers',\n          confidence: 0.78\n        }\n      ];\n    }\n  }\n\n  async getChatResponse(data: ChatMessage): Promise<any> {\n    try {\n      const { message, userId } = data;\n\n      // Analyse de l\'intention\n      const intention = this.analyzeIntention(message);\n\n      switch (intention.type) {\n        case 'reservation':\n          return await this.handleReservationIntent(message, userId);\n        case 'menu':\n          return await this.handleMenuIntent(message);\n        case 'order_status':\n          return await this.handleOrderStatusIntent(message, userId);\n        case 'recommendation':\n          return await this.handleRecommendationIntent(userId);\n        default:\n          return {\n            response: \"Je ne suis pas s√ªr de comprendre. Puis-je vous aider avec une r√©servation, des informations sur le menu, ou autre chose ?\",\n            actions: [],\n            confidence: 0.3\n          };\n      }\n    } catch (error) {\n      logger.error('Erreur chat IA:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      return {\n        response: \"D√©sol√©, je rencontre un probl√®me technique. Veuillez r√©essayer.\",\n        actions: [],\n        confidence: 0\n      };\n    }\n  }\n\n  private analyzeIntention(message: string): { type: string; confidence: number; entities: unknown[] } {\n    const lowercaseMessage = message.toLowerCase();\n\n    // Mots-cl√©s pour diff√©rentes intentions\n    const reservationKeywords = ['r√©server', 'r√©servation', 'table', 'r√©server une table'];\n    const menuKeywords = ['menu', 'carte', 'plat', 'boisson', 'caf√©'];\n    const orderKeywords = ['commande', 'livraison'];\n\n    let maxScore = 0;\n    let detectedIntent = 'general';\n\n    if (reservationKeywords.some(keyword => lowercaseMessage.includes(keyword))) {\n      detectedIntent = 'reservation';\n      maxScore = 0.8;\n    } else if (menuKeywords.some(keyword => lowercaseMessage.includes(keyword))) {\n      detectedIntent = 'menu';\n      maxScore = 0.7;\n    } else if (orderKeywords.some(keyword => lowercaseMessage.includes(keyword))) {\n      detectedIntent = 'order_status';\n      maxScore = 0.6;\n    }\n\n    return {\n      type: detectedIntent,\n      confidence: maxScore,\n      entities: this.extractEntities(message)\n    };\n  }\n\n  private async handleReservationIntent(message: string, userId?: number): Promise<any> {\n    // Logique de r√©servation bas√©e sur l'IA\n    return {\n      response: \"Je peux vous aider avec votre r√©servation. Combien de personnes serez-vous et pour quelle date ?\",\n      actions: ['show_reservation_form',],\n      confidence: 0.9\n    };\n  }\n\n  private async handleMenuIntent(message: string): Promise<any> {\n    try {\n      const db = await getDb();\n      const items = await db.select().from(menuItems).limit(5);\n\n      return {\n        response: \"Voici quelques suggestions de notre menu :\",\n        data: items,\n        actions: ['show_menu',],\n        confidence: 0.8\n      };\n    } catch (error) {\n      logger.error('Erreur lors de la r√©cup√©ration du menu:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      return {\n        response: \"Voici notre menu principal...\",\n        actions: ['show_menu',],\n        confidence: 0.6\n      };\n    }\n  }\n\n  private async handleOrderStatusIntent(message: string, userId?: number): Promise<any> {\n    return {\n      response: \"Laissez-moi v√©rifier le statut de votre commande...\",\n      actions: ['check_order_status',],\n      confidence: 0.7\n    };\n  }\n\n  private async handleRecommendationIntent(userId?: number): Promise<any> {\n    return {\n      response: \"Bas√© sur vos pr√©f√©rences, je recommande notre caf√© signature...\",\n      actions: ['show_recommendations',],\n      confidence: 0.8\n    };\n  }\n\n  private extractEntities(message: string): unknown[] {\n    // Extraction d'entit√©s simple\n    const entities: unknown[] = [];\n\n    // Extraction de dates\n    const dateRegex = /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/g;\n    const dates = message.match(dateRegex);\n    if (dates) {\n      entities.push({ type: 'date', value: dates[0] });\n    }\n\n    // Extraction de nombres (pour nombre de personnes)\n    const numberRegex = /(\\d+)\\s*(personne|gens|personnes)/g;\n    const numbers = message.match(numberRegex);\n    if (numbers) {\n      // Ensure parseInt is called correctly and handles potential non-numeric matches\n      const parsedNumber = parseInt(numbers[0].match(/\\d+/)?.[0] || '0', 10);\n      if (!isNaN(parsedNumber)) {\n        entities.push({ type: 'party_size', value: parsedNumber });\n      }\n    }\n\n    return entities;\n  }\n\n  async analyzeVoiceInput(data: z.infer<typeof VoiceAnalysisSchema>) {\n    const { audioData, language, userId } = VoiceAnalysisSchema.parse(data);\n\n    try {\n      // Simulation d'analyse vocale - √† remplacer par un vrai service ASR\n      const transcribedText = this.simulateSpeechRecognition(audioData);\n      const chatResponse = await this.processChatMessage({\n        message: transcribedText,\n        userId: userId?.toString(),\n        sessionId: `voice_${userId}`\n      });\n\n      return {\n        transcription: transcribedText,\n        response: chatResponse.response,\n        actions: chatResponse.actions,\n        confidence: 0.85\n      };\n    } catch (error) {\n      logger.error('Erreur analyse vocale:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      throw new Error('√âchec de l\'analyse vocale');\n    }\n  }\n\n  private simulateSpeechRecognition(audioData: string): string {\n    // Simulation basique - √† remplacer par une vraie API ASR\n    const commonPhrases = [\n      \"Je voudrais r√©server une table pour ce soir\",\n      \"Quels sont vos horaires d'ouverture ?\",\n      \"Je veux commander un cappuccino\",\n      \"Avez-vous des promotions en ce moment ?\",\n      \"Peut-on venir en groupe ?\"\n    ];\n\n    const phrase = commonPhrases[Math.floor(Math.random() * commonPhrases.length)];\n    return phrase || 'Phrase par d√©faut';\n  }\n\n  async detectAnomalies(data: AnomalyRequest) {\n    const { metric, period } = data;\n\n    try {\n      const db = getDb();\n      const anomalies = await db.select({\n        timestamp: orders.createdAt,\n        value: sql`SUM(orders.total_amount)`,\n        expected: sql`AVG(SUM(orders.total_amount)) OVER (ORDER BY DATE(orders.created_at) ROWS BETWEEN 7 PRECEDING AND 1 PRECEDING)`\n      }).from(orders)\n        .groupBy(sql`DATE(orders.created_at)`) \n        .having(sql`ABS(SUM(orders.total_amount) - AVG(SUM(orders.total_amount)) OVER (ORDER BY DATE(orders.created_at) ROWS BETWEEN 7 PRECEDING AND 1 PRECEDING)) > \n                   COALESCE(STDDEV(SUM(orders.total_amount)) OVER (ORDER BY DATE(orders.created_at) ROWS BETWEEN 7 PRECEDING AND 1 PRECEDING) * 2, 100)`)\n        .where(gte(orders.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)));\n\n      return anomalies.map((anomaly: any) => ({\n        id: anomaly.id,\n        type: anomaly.type,\n        severity: anomaly.severity,\n        description: anomaly.description,\n        detectedAt: anomaly.detectedAt,\n        affectedMetrics: anomaly.affectedMetrics\n      }));\n    } catch (error) {\n      logger.error('Erreur d√©tection anomalies:', { error: error instanceof Error ? error.message : 'Erreur inconnue' });\n      return [];\n    }\n  }\n\n  private async generateInsight(data: Record<string, unknown>): Promise<string> {\n    // Simulation d'analyse IA\n    const insights = [\n      'Les ventes de caf√© augmentent de 15% le matin',\n      'Recommandation: Augmenter le stock de lait d\'amande',\n      'Tendance: Les clients pr√©f√®rent les boissons chaudes en hiver'\n    ];\n    const insight = insights[Math.floor(Math.random() * insights.length)];\n    return insight || 'Insight par d√©faut';\n  }\n\n  private async optimizeMenu(menuData: Record<string, unknown>): Promise<Record<string, unknown>> {\n    // Placeholder logic for menu optimization\n    return { ...menuData, optimizationStatus: 'optimized' };\n  }\n\n  private async predictDemand(salesData: Record<string, unknown>[]): Promise<Record<string, unknown>> {\n    // Simulation de pr√©diction de demande\n    return {\n      predictions: [\n        { item: 'Espresso', demand: 85 },\n        { item: 'Cappuccino', demand: 72 },\n        { item: 'Croissant', demand: 45 }\n      ],\n      accuracy: 0.87\n    };\n  }\n}\n\n// Export de l'instance singleton\nexport const aiService = AIAutomationService.getInstance();\n"
  }
]